To obtain the counter-example, i.e., assigning 
suitable value to the inputs, we rely on CBMC \cite{Clarke04CBMC} . 
Specifically, for a given upper bound, CBMC verifies the specified  assertions. If any violation of an
assertion is detected, a counter-example is generated. Let us consider the 
\textit{cTraces} as shown in Fig.~\subref*{SubFig:CM0} and Fig.~\subref*{SubFig:CM1}. The input to the CBMC in C 
for this case is shown in Fig~\ref{Fig:CBMCInput}. 

The variables appearing in the \textit{cTrace} of $M_0$
(Fig.~\subref*{SubFig:CM0}) are suffixed with $\mathtt{\_s}$,whereas 
the variables appearing in the \textit{cTrace} of $M_1$ (Fig.~\subref*{SubFig:CM1}) are
suffixed with $\mathtt{\_t}$. Since program equivalence entails identical output(s)
generated by the two programs when fed with the same input(s), the input variable
$n$ is not suffixed with either $\mathtt{\_s}$ or $\mathtt{\_t}$. Lines~3 and 4
declare the variables appearing in the \textit{cTrace} of $M_0$ and the
\textit{cTrace} of $M_1$, respectively, along with their data type which is
integer for all the variables. The lines 8--16 and 18--26 capture the data
transformations and the conditions of execution of the paths appearing in the
\textit{cTrace} of the $M_0$ and $M_1$, respectively. We use
\texttt{\_\_CPROVER\_assume} statements to allow only those computation
that satisfy a given condition. For example CBMC first picks the value for $n$
non-deterministically from the domain of integers. The statement
\texttt{\_\_CPROVER\_assume($n\geq 0$)} at line~5 further restricts the range
of $n$ for all program computations to be greater than or equal to 0. Note that
if there is no computation satisfying the condition, say $P$, mentioned in
\texttt{\_\_CPROVER\_assume} statement, then all the assertions hold
vacuously. We check this by adding \texttt{assert($!P$)} statement after each
\texttt{\_\_CPROVER\_assume} statement so that if one of the
\texttt{assert($!P$)} statement is true then we declare that all the possible
computations represented by \textit{cTrace} are false computations
\cite{Chouksey17} i.e., they never execute. Finally, we check the equivalence
of the live variables  ($x\_s,y\_s,x\_t,y\_t$) and output variables ($\mathit{out\_s}$,
$\mathit{out\_t}$) using  the \texttt{assert} statements (lines
\texttt{27}--\texttt{29}).

CBMC is able to automatically determine an upper bound on the number of loop iterations
in many cases. It  may fail if the number of loop iterations is highly data-dependent.
Therefore, to verify the assertions with CBMC we use the following command:
\texttt{cbmc fileName.c -unwind k --no-unwinding-assertions} where 
\textit{fileName.c} is the name of the target program, $k$ is the bound on the 
number of iterations of the loop in the program called as Unwinding Loop 
Bound (ULB) and \texttt{--no-unwinding-assertions} disables the unwinding assertion 
check and changes the unwinding assertion to an unwinding assumption. We use the 
option \texttt{--no-unwinding-assertions} so that a counter-example 
might be found within the small state space generated with the small ULB. If 
the target program contains a loop then CBMC unwinds the loop $k$ times 
and check the properties. Note that if there are multiple loops in the program, 
the bound $k$ applies to all loops. A violation of the property is reported if 
it is found within $k$ ULB and CBMC will give a counter-example. Otherwise, we 
iteratively run CBMC with increasing ULBs for the loops until an 
assertion violation is found or a given time limit is reached. 
\begin{comment}
There are two 
possible outcomes by CBMC for a given ULB.
\begin{itemize}
\item \textit{Counter-example:} The CBMC reports a counter-example, i.e., it 
has 
found input data within a given ULB for which the user-defined assertion is not 
valid.
\item \textit{No counter-example:} There are two possibilities when CBMC does not 
report a counter-example for a given ULB.
\begin{itemize}
\item CBMC hits the time limit and no counter-example has been found. In 
this case it is possible that the user-defined assertions are indeed valid  
or the counterexamples are too complex to be found within a given time limit.
\item CBMC does not hit the time limit and does not report a counter-example. 
In this case, if unwinding assertion fails (i.e., the loop can execute more then 
ULB times) then we execute CBMC with increasing number of ULBs. Otherwise, CBMC 
proved assertions to be valid, it indeed was.
\end{itemize}
\end{itemize}

Note that if no counterexample is found with depth $k$ then unwinding assertion 
is verified 
along with the user defined assertion.
if unwinding assertion fails then a violation of the property could still occur 
in further iterations of the loop. Hence  Otherwise CBMC proved a property to 
be valid, it indeed 
was.

we used 1000 second timeout for CBMC.
For our experiment we used CBMC (built from revision 4503,
used with Z3 as the decision procedure)

No counterexample The tool has hit the time limit and no counterexample has 
been found. Thus, either the solution is correct or the counterexamples are too 
complex to be found within the available time.
\end{comment}
