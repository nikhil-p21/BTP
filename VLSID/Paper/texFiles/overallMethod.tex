The abstract version of our counter-example generation  represented by the
function $\mathtt{counterExmapleGenerator}$ is presented in Algorithm~\ref{Algo:ctrace}.  The control flow of
Algorithm~\ref{Algo:ctrace} is given in Fig.~\ref{Fig:CFG}.
The function $\mathtt{counterExmapleGenerator}$ takes as input two FSMDs $M_0$ and $M_1$, a
path $\alpha$ from the path cover of $M_0$, a  path $\beta$ from the path cover of
$M_1$, $\mathtt{EQ\_LIST}$ contains equivalent path pairs and
$\mathtt{C\_LIST}$ contains candidates for conditionally equivalent path pairs.
The function $\mathtt{counterExmapleGenerator}$ returns
$\langle\bar{v},\mathit{Equiv},\mathit{falseComp}\rangle$, where $\bar{v}=\langle
v_1,v_2,\dots,v_n\rangle$ is the input variable list such  that $v_i$ represents the
value of the input variable $v_i$, $\mathit{Equiv}$ is
$\mathtt{True}$ if $\alpha\simeq\beta$ and $\mathtt{False}$ otherwise and 
$\mathit{falseComp}$ is $\mathtt{True}$ if all the
computations represented by \textit{cTrace} are false computations and 
$\mathtt{False}$ otherwise. In lines~\ref{Line:ctraceM0}--\ref{Line:ctraceM1} of
Algorithm~\ref{Algo:ctrace}, a \textit{cTrace} is constructed from the
$\mathtt{EQ\_LIST}$ and $\mathtt{C\_LIST}$ as discussed in Sec.~\ref{Sec:CTrace}. The
\textit{cTrace} is encoded as input to CBMC at line~\ref{Line:encode}. The
output generated by CBMC may result in various scenarios as discussed in
Sec.~\ref{Sec:incorpoResult}.  Lines~\ref{Line:caseStart}--\ref{Line:caseEnd}
of Algorithm~\ref{Algo:ctrace} handle  these cases.

The enhanced version of $\mathtt{correspondenceChecker}$ function of the EVP method \cite{Chouksey18} after incorporating
 the result of the function $\mathtt{counterExmapleGenerator}$ is presented in 
Algorithm~\ref{Algo:correspondenceChecker}. In case of failure,
Algorithm~\ref{Algo:correspondenceChecker} invokes the function
$\mathtt{counterExmapleGenerator}$ (Algorithm~\ref{Algo:ctrace}) at
line~\ref{Line:counter}. It may be noted that the EVP method reports failure under this scenario.
  If $\mathtt{counterExmapleGenerator}$
returns a counter-example (i.e., $\bar{v}\neq \mathtt{NULL}$) then the function
$\mathtt{correspondenceChecker}$ returns ``Not equivalent" i.e., the two FSMDs are
not equivalent (line~17). If CBMC hits the time limit then  we
cannot decide whether $M_0$ is equivalent to  $M_1$. Hence the function
$\mathtt{correspondenceChecker}$ returns ``May Not be Equivalent" (line~23). If
CBMC reports that all the possible computations represented by \textit{cTrace}
are false computations (i.e., the variable $\mathit{falseComp}$ is
$\mathtt{True}$) then the function $\mathtt{correspondenceChecker}$ needs to be
modified to handle this scenario (line~15). 
If CBMC finds the mismatch in the values of a live variable but outputs of the
two programs are the same then we do not report the counter-example (line~21). To handle this 
case also $\mathtt{correspondenceChecker}$ needs to be modified. 
If CBMC declares that the path pair
($\alpha,\beta$) are equivalent (i.e., the variable $\mathit{Equiv}$ is
$\mathtt{True}$) then it is a false negative result of the
$\mathtt{correspondenceChecker}$ function (line~19). The
$\mathtt{correspondenceChecker}$ function must take some decision to avoid the
false negative case in the future.
